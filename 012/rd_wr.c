/* This file generated by mkprj.sh */
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <signal.h>
#include <unistd.h>
#include <pthread.h>
#include <malloc.h>


typedef struct params{
	pthread_t	thread_id; 	/* ID returned by pthread_create() */
} params_t;

int cancel = 0;
pthread_mutex_t mutex;
int wrs, rds, max;
int *vector;

void my_signal_handler(int sig)
{
	printf("sig = %d", sig);
	switch(sig) {
		case SIGINT:
			puts("Exiting...");
			cancel = 1;
		default:
			break;
	}
}

void* thread_writers(void* arg)
{
	int i;
	while(!cancel) {
		pthread_mutex_lock (&mutex);
		for(i = 0; i < max; i++) 
			if(vector[i] == 0) {vector[i] = 1; break;}
		pthread_mutex_unlock (&mutex);
	}
	return 0;
}



void* thread_readers(void* arg)
{
	int i;
	while(!cancel) {
		pthread_mutex_lock (&mutex);
		for(i = 0; i < max; i++) 
			if(vector[i] == 1) {vector[i] = 0; break;}
		pthread_mutex_unlock (&mutex);
	}
	return 0;
}


int main(int argc, char** argv, char** env)
{

	params_t *p_rds, *p_wrs;
	int i;

	if(argc < 4) {
		printf("usage:\t%s writers readers max\n", argv[0]);
		puts("writers - количество писателей");
		puts("readers - количество читателей");
		puts("max - максимальное количество элементов в контейнере");
		return 0;

	}
	wrs = atoi(argv[1]);
	rds = atoi(argv[2]);
	max = atoi(argv[3]);

	if(wrs <= 0) {
		perror(argv[1]);
		exit(EXIT_FAILURE);
	}

	if(rds <= 0) {
		perror(argv[2]);
		exit(EXIT_FAILURE);
	}

	if(max < 0) {
		perror(argv[3]);
		exit(EXIT_FAILURE);
	}
#if 0
	signal(SIGINT, my_signal_handler);
#else
	static struct sigaction act_s;
	act_s.sa_handler = my_signal_handler;
	sigaction(SIGINT, &act_s, NULL);
#endif
	vector = calloc(sizeof(int), max);
	p_wrs = calloc(sizeof(pthread_t), wrs);
	if(p_wrs == NULL) {
		perror("malloc wrs");
		exit(EXIT_FAILURE);
	}
	for(i = 0; i < wrs; i++) {
		if(pthread_create(&p_wrs[i].thread_id, NULL, &thread_writers, NULL) != 0) {
			perror("pthread wrs create");
			exit(EXIT_FAILURE);
		}
	}

	p_rds = calloc(sizeof(pthread_t), rds);
	if(p_rds == NULL) {
		perror("malloc rds");
		exit(EXIT_FAILURE);
	}
	for(i = 0; i < rds; i++) {
		if(pthread_create(&p_rds[i].thread_id, NULL, &thread_readers, NULL) != 0) {
			perror("pthread rds create");
			exit(EXIT_FAILURE);
		}
	}

	while(!cancel) {
		int num;
		usleep(100000);
		pthread_mutex_lock(&mutex);
		for(i = 0, num = 0; i < max; i++)
			if(vector[i]) num++;
		printf("vector: %d\n", num);
		pthread_mutex_unlock(&mutex);

	}
	free(p_wrs);
	free(p_rds);
	free(vector);
	return 0;
}
